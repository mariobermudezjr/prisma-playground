import { DMMF, DMMFClass, Engine } from './runtime';
/**
 * Utility Types
 */
export declare type Enumerable<T> = T | Array<T>;
export declare type MergeTruthyValues<R extends object, S extends object> = {
    [key in keyof S | keyof R]: key extends false ? never : key extends keyof S ? S[key] extends false ? never : S[key] : key extends keyof R ? R[key] : never;
};
export declare type CleanupNever<T> = {
    [key in keyof T]: T[key] extends never ? never : key;
}[keyof T];
/**
 * Subset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
 */
export declare type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
};
declare class PhotonFetcher {
    private readonly photon;
    private readonly engine;
    private readonly debug;
    private readonly hooks?;
    constructor(photon: Photon, engine: Engine, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, path?: string[], rootField?: string, typeName?: string, isList?: boolean): Promise<T>;
    protected unpack(data: any, path: string[], rootField?: string, isList?: boolean): any;
}
/**
 * Client
**/
export declare type Datasources = {
    db?: string;
};
export interface PhotonOptions {
    datasources?: Datasources;
    debug?: boolean | {
        engine?: boolean;
        library?: boolean;
    };
    /**
     * You probably don't want to use this. `__internal` is used by internal tooling.
     */
    __internal?: {
        hooks?: Hooks;
        engine?: {
            cwd?: string;
            binaryPath?: string;
        };
    };
}
export declare type Hooks = {
    beforeRequest?: (options: {
        query: string;
        path: string[];
        rootField?: string;
        typeName?: string;
        document: any;
    }) => any;
};
export default class Photon {
    private fetcher;
    private readonly dmmf;
    private readonly engine;
    private readonly datamodel;
    private connectionPromise?;
    constructor(options?: PhotonOptions);
    private connectEngine;
    connect(): Promise<void>;
    disconnect(): Promise<void>;
    readonly users: UserDelegate;
    readonly todos: TodoDelegate;
}
export declare const OrderByArg: {
    asc: "asc";
    desc: "desc";
};
export declare type OrderByArg = (typeof OrderByArg)[keyof typeof OrderByArg];
/**
 * Model User
 */
export declare type User = {
    id: string;
    email: string;
    name: string | null;
};
export declare type UserScalars = 'id' | 'email' | 'name';
export declare type UserSelect = {
    id?: boolean;
    email?: boolean;
    name?: boolean;
    todos?: boolean | FindManyTodoSelectArgsOptional;
};
export declare type UserInclude = {
    todos?: boolean | FindManyTodoIncludeArgsOptional;
};
declare type UserDefault = {
    id: true;
    email: true;
    name: true;
};
declare type UserGetSelectPayload<S extends boolean | UserSelect> = S extends true ? User : S extends UserSelect ? {
    [P in CleanupNever<MergeTruthyValues<{}, S>>]: P extends UserScalars ? User[P] : P extends 'todos' ? Array<TodoGetSelectPayload<ExtractFindManyTodoSelectArgs<S[P]>>> : never;
} : never;
declare type UserGetIncludePayload<S extends boolean | UserInclude> = S extends true ? User : S extends UserInclude ? {
    [P in CleanupNever<MergeTruthyValues<UserDefault, S>>]: P extends UserScalars ? User[P] : P extends 'todos' ? Array<TodoGetIncludePayload<ExtractFindManyTodoIncludeArgs<S[P]>>> : never;
} : never;
export interface UserDelegate {
    <T extends FindManyUserArgs>(args?: Subset<T, FindManyUserArgs>): T extends FindManyUserArgsRequired ? 'Please either choose `select` or `include`' : T extends FindManyUserSelectArgs ? Promise<Array<UserGetSelectPayload<ExtractFindManyUserSelectArgs<T>>>> : T extends FindManyUserIncludeArgs ? Promise<Array<UserGetIncludePayload<ExtractFindManyUserIncludeArgs<T>>>> : Promise<Array<User>>;
    findOne<T extends FindOneUserArgs>(args: Subset<T, FindOneUserArgs>): T extends FindOneUserArgsRequired ? 'Please either choose `select` or `include`' : T extends FindOneUserSelectArgs ? Promise<UserGetSelectPayload<ExtractFindOneUserSelectArgs<T>>> : T extends FindOneUserIncludeArgs ? Promise<UserGetIncludePayload<ExtractFindOneUserIncludeArgs<T>>> : UserClient<User>;
    findMany<T extends FindManyUserArgs>(args?: Subset<T, FindManyUserArgs>): T extends FindManyUserArgsRequired ? 'Please either choose `select` or `include`' : T extends FindManyUserSelectArgs ? Promise<Array<UserGetSelectPayload<ExtractFindManyUserSelectArgs<T>>>> : T extends FindManyUserIncludeArgs ? Promise<Array<UserGetIncludePayload<ExtractFindManyUserIncludeArgs<T>>>> : Promise<Array<User>>;
    create<T extends UserCreateArgs>(args: Subset<T, UserCreateArgs>): T extends UserCreateArgsRequired ? 'Please either choose `select` or `include`' : T extends UserSelectCreateArgs ? Promise<UserGetSelectPayload<ExtractUserSelectCreateArgs<T>>> : T extends UserIncludeCreateArgs ? Promise<UserGetIncludePayload<ExtractUserIncludeCreateArgs<T>>> : UserClient<User>;
    delete<T extends UserDeleteArgs>(args: Subset<T, UserDeleteArgs>): T extends UserDeleteArgsRequired ? 'Please either choose `select` or `include`' : T extends UserSelectDeleteArgs ? Promise<UserGetSelectPayload<ExtractUserSelectDeleteArgs<T>>> : T extends UserIncludeDeleteArgs ? Promise<UserGetIncludePayload<ExtractUserIncludeDeleteArgs<T>>> : UserClient<User>;
    update<T extends UserUpdateArgs>(args: Subset<T, UserUpdateArgs>): T extends UserUpdateArgsRequired ? 'Please either choose `select` or `include`' : T extends UserSelectUpdateArgs ? Promise<UserGetSelectPayload<ExtractUserSelectUpdateArgs<T>>> : T extends UserIncludeUpdateArgs ? Promise<UserGetIncludePayload<ExtractUserIncludeUpdateArgs<T>>> : UserClient<User>;
    deleteMany<T extends UserDeleteManyArgs>(args: Subset<T, UserDeleteManyArgs>): T extends UserDeleteManyArgsRequired ? 'Please either choose `select` or `include`' : T extends UserSelectDeleteManyArgs ? Promise<UserGetSelectPayload<ExtractUserSelectDeleteManyArgs<T>>> : T extends UserIncludeDeleteManyArgs ? Promise<UserGetIncludePayload<ExtractUserIncludeDeleteManyArgs<T>>> : UserClient<User>;
    updateMany<T extends UserUpdateManyArgs>(args: Subset<T, UserUpdateManyArgs>): T extends UserUpdateManyArgsRequired ? 'Please either choose `select` or `include`' : T extends UserSelectUpdateManyArgs ? Promise<UserGetSelectPayload<ExtractUserSelectUpdateManyArgs<T>>> : T extends UserIncludeUpdateManyArgs ? Promise<UserGetIncludePayload<ExtractUserIncludeUpdateManyArgs<T>>> : UserClient<User>;
    upsert<T extends UserUpsertArgs>(args: Subset<T, UserUpsertArgs>): T extends UserUpsertArgsRequired ? 'Please either choose `select` or `include`' : T extends UserSelectUpsertArgs ? Promise<UserGetSelectPayload<ExtractUserSelectUpsertArgs<T>>> : T extends UserIncludeUpsertArgs ? Promise<UserGetIncludePayload<ExtractUserIncludeUpsertArgs<T>>> : UserClient<User>;
}
export declare class UserClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _path;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: DMMFClass, _fetcher: PhotonFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: UserArgs, _path: string[], _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PhotonPromise';
    todos<T extends FindManyTodoArgs = {}>(args?: Subset<T, FindManyTodoArgs>): T extends FindManyTodoArgsRequired ? 'Please either choose `select` or `include`' : T extends FindManyTodoSelectArgs ? Promise<Array<TodoGetSelectPayload<ExtractFindManyTodoSelectArgs<T>>>> : T extends FindManyTodoIncludeArgs ? Promise<Array<TodoGetIncludePayload<ExtractFindManyTodoIncludeArgs<T>>>> : Promise<Array<Todo>>;
    private readonly _document;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}
/**
 * User findOne
 */
export declare type FindOneUserArgs = {
    select?: UserSelect | null;
    include?: UserInclude | null;
    where: UserWhereUniqueInput;
};
export declare type FindOneUserArgsRequired = {
    select: UserSelect;
    include: UserInclude;
    where: UserWhereUniqueInput;
};
export declare type FindOneUserSelectArgs = {
    select: UserSelect;
    where: UserWhereUniqueInput;
};
export declare type FindOneUserSelectArgsOptional = {
    select?: UserSelect | null;
    where: UserWhereUniqueInput;
};
export declare type FindOneUserIncludeArgs = {
    include: UserInclude;
    where: UserWhereUniqueInput;
};
export declare type FindOneUserIncludeArgsOptional = {
    include?: UserInclude | null;
    where: UserWhereUniqueInput;
};
export declare type ExtractFindOneUserSelectArgs<S extends undefined | boolean | FindOneUserSelectArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends FindOneUserSelectArgs ? S['select'] : true;
export declare type ExtractFindOneUserIncludeArgs<S extends undefined | boolean | FindOneUserIncludeArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends FindOneUserIncludeArgs ? S['include'] : true;
/**
 * User findMany
 */
export declare type FindManyUserArgs = {
    select?: UserSelect | null;
    include?: UserInclude | null;
    where?: UserWhereInput | null;
    orderBy?: UserOrderByInput | null;
    skip?: number | null;
    after?: string | null;
    before?: string | null;
    first?: number | null;
    last?: number | null;
};
export declare type FindManyUserArgsRequired = {
    select: UserSelect;
    include: UserInclude;
    where?: UserWhereInput | null;
    orderBy?: UserOrderByInput | null;
    skip?: number | null;
    after?: string | null;
    before?: string | null;
    first?: number | null;
    last?: number | null;
};
export declare type FindManyUserSelectArgs = {
    select: UserSelect;
    where?: UserWhereInput | null;
    orderBy?: UserOrderByInput | null;
    skip?: number | null;
    after?: string | null;
    before?: string | null;
    first?: number | null;
    last?: number | null;
};
export declare type FindManyUserSelectArgsOptional = {
    select?: UserSelect | null;
    where?: UserWhereInput | null;
    orderBy?: UserOrderByInput | null;
    skip?: number | null;
    after?: string | null;
    before?: string | null;
    first?: number | null;
    last?: number | null;
};
export declare type FindManyUserIncludeArgs = {
    include: UserInclude;
    where?: UserWhereInput | null;
    orderBy?: UserOrderByInput | null;
    skip?: number | null;
    after?: string | null;
    before?: string | null;
    first?: number | null;
    last?: number | null;
};
export declare type FindManyUserIncludeArgsOptional = {
    include?: UserInclude | null;
    where?: UserWhereInput | null;
    orderBy?: UserOrderByInput | null;
    skip?: number | null;
    after?: string | null;
    before?: string | null;
    first?: number | null;
    last?: number | null;
};
export declare type ExtractFindManyUserSelectArgs<S extends undefined | boolean | FindManyUserSelectArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends FindManyUserSelectArgs ? S['select'] : true;
export declare type ExtractFindManyUserIncludeArgs<S extends undefined | boolean | FindManyUserIncludeArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends FindManyUserIncludeArgs ? S['include'] : true;
/**
 * User create
 */
export declare type UserCreateArgs = {
    select?: UserSelect | null;
    include?: UserInclude | null;
    data: UserCreateInput;
};
export declare type UserCreateArgsRequired = {
    select: UserSelect;
    include: UserInclude;
    data: UserCreateInput;
};
export declare type UserSelectCreateArgs = {
    select: UserSelect;
    data: UserCreateInput;
};
export declare type UserSelectCreateArgsOptional = {
    select?: UserSelect | null;
    data: UserCreateInput;
};
export declare type UserIncludeCreateArgs = {
    include: UserInclude;
    data: UserCreateInput;
};
export declare type UserIncludeCreateArgsOptional = {
    include?: UserInclude | null;
    data: UserCreateInput;
};
export declare type ExtractUserSelectCreateArgs<S extends undefined | boolean | UserSelectCreateArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends UserSelectCreateArgs ? S['select'] : true;
export declare type ExtractUserIncludeCreateArgs<S extends undefined | boolean | UserIncludeCreateArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends UserIncludeCreateArgs ? S['include'] : true;
/**
 * User update
 */
export declare type UserUpdateArgs = {
    select?: UserSelect | null;
    include?: UserInclude | null;
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
};
export declare type UserUpdateArgsRequired = {
    select: UserSelect;
    include: UserInclude;
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
};
export declare type UserSelectUpdateArgs = {
    select: UserSelect;
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
};
export declare type UserSelectUpdateArgsOptional = {
    select?: UserSelect | null;
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
};
export declare type UserIncludeUpdateArgs = {
    include: UserInclude;
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
};
export declare type UserIncludeUpdateArgsOptional = {
    include?: UserInclude | null;
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
};
export declare type ExtractUserSelectUpdateArgs<S extends undefined | boolean | UserSelectUpdateArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends UserSelectUpdateArgs ? S['select'] : true;
export declare type ExtractUserIncludeUpdateArgs<S extends undefined | boolean | UserIncludeUpdateArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends UserIncludeUpdateArgs ? S['include'] : true;
/**
 * User updateMany
 */
export declare type UserUpdateManyArgs = {
    select?: UserSelect | null;
    include?: UserInclude | null;
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput | null;
};
export declare type UserUpdateManyArgsRequired = {
    select: UserSelect;
    include: UserInclude;
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput | null;
};
export declare type UserSelectUpdateManyArgs = {
    select: UserSelect;
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput | null;
};
export declare type UserSelectUpdateManyArgsOptional = {
    select?: UserSelect | null;
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput | null;
};
export declare type UserIncludeUpdateManyArgs = {
    include: UserInclude;
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput | null;
};
export declare type UserIncludeUpdateManyArgsOptional = {
    include?: UserInclude | null;
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput | null;
};
export declare type ExtractUserSelectUpdateManyArgs<S extends undefined | boolean | UserSelectUpdateManyArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends UserSelectUpdateManyArgs ? S['select'] : true;
export declare type ExtractUserIncludeUpdateManyArgs<S extends undefined | boolean | UserIncludeUpdateManyArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends UserIncludeUpdateManyArgs ? S['include'] : true;
/**
 * User upsert
 */
export declare type UserUpsertArgs = {
    select?: UserSelect | null;
    include?: UserInclude | null;
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
};
export declare type UserUpsertArgsRequired = {
    select: UserSelect;
    include: UserInclude;
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
};
export declare type UserSelectUpsertArgs = {
    select: UserSelect;
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
};
export declare type UserSelectUpsertArgsOptional = {
    select?: UserSelect | null;
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
};
export declare type UserIncludeUpsertArgs = {
    include: UserInclude;
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
};
export declare type UserIncludeUpsertArgsOptional = {
    include?: UserInclude | null;
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
};
export declare type ExtractUserSelectUpsertArgs<S extends undefined | boolean | UserSelectUpsertArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends UserSelectUpsertArgs ? S['select'] : true;
export declare type ExtractUserIncludeUpsertArgs<S extends undefined | boolean | UserIncludeUpsertArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends UserIncludeUpsertArgs ? S['include'] : true;
/**
 * User delete
 */
export declare type UserDeleteArgs = {
    select?: UserSelect | null;
    include?: UserInclude | null;
    where: UserWhereUniqueInput;
};
export declare type UserDeleteArgsRequired = {
    select: UserSelect;
    include: UserInclude;
    where: UserWhereUniqueInput;
};
export declare type UserSelectDeleteArgs = {
    select: UserSelect;
    where: UserWhereUniqueInput;
};
export declare type UserSelectDeleteArgsOptional = {
    select?: UserSelect | null;
    where: UserWhereUniqueInput;
};
export declare type UserIncludeDeleteArgs = {
    include: UserInclude;
    where: UserWhereUniqueInput;
};
export declare type UserIncludeDeleteArgsOptional = {
    include?: UserInclude | null;
    where: UserWhereUniqueInput;
};
export declare type ExtractUserSelectDeleteArgs<S extends undefined | boolean | UserSelectDeleteArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends UserSelectDeleteArgs ? S['select'] : true;
export declare type ExtractUserIncludeDeleteArgs<S extends undefined | boolean | UserIncludeDeleteArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends UserIncludeDeleteArgs ? S['include'] : true;
/**
 * User deleteMany
 */
export declare type UserDeleteManyArgs = {
    select?: UserSelect | null;
    include?: UserInclude | null;
    where?: UserWhereInput | null;
};
export declare type UserDeleteManyArgsRequired = {
    select: UserSelect;
    include: UserInclude;
    where?: UserWhereInput | null;
};
export declare type UserSelectDeleteManyArgs = {
    select: UserSelect;
    where?: UserWhereInput | null;
};
export declare type UserSelectDeleteManyArgsOptional = {
    select?: UserSelect | null;
    where?: UserWhereInput | null;
};
export declare type UserIncludeDeleteManyArgs = {
    include: UserInclude;
    where?: UserWhereInput | null;
};
export declare type UserIncludeDeleteManyArgsOptional = {
    include?: UserInclude | null;
    where?: UserWhereInput | null;
};
export declare type ExtractUserSelectDeleteManyArgs<S extends undefined | boolean | UserSelectDeleteManyArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends UserSelectDeleteManyArgs ? S['select'] : true;
export declare type ExtractUserIncludeDeleteManyArgs<S extends undefined | boolean | UserIncludeDeleteManyArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends UserIncludeDeleteManyArgs ? S['include'] : true;
/**
 * User without action
 */
export declare type UserArgs = {
    select?: UserSelect | null;
    include?: UserInclude | null;
};
export declare type UserArgsRequired = {
    select: UserSelect;
    include: UserInclude;
};
export declare type UserSelectArgs = {
    select: UserSelect;
};
export declare type UserSelectArgsOptional = {
    select?: UserSelect | null;
};
export declare type UserIncludeArgs = {
    include: UserInclude;
};
export declare type UserIncludeArgsOptional = {
    include?: UserInclude | null;
};
export declare type ExtractUserSelectArgs<S extends undefined | boolean | UserSelectArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends UserSelectArgs ? S['select'] : true;
export declare type ExtractUserIncludeArgs<S extends undefined | boolean | UserIncludeArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends UserIncludeArgs ? S['include'] : true;
/**
 * Model Todo
 */
export declare type Todo = {
    id: string;
    createdAt: string;
    updatedAt: string;
    title: string;
    prioritize: boolean | null;
    completed: boolean | null;
};
export declare type TodoScalars = 'id' | 'createdAt' | 'updatedAt' | 'title' | 'prioritize' | 'completed';
export declare type TodoSelect = {
    id?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    title?: boolean;
    prioritize?: boolean;
    completed?: boolean;
    author?: boolean | UserSelectArgsOptional;
};
export declare type TodoInclude = {
    author?: boolean | UserIncludeArgsOptional;
};
declare type TodoDefault = {
    id: true;
    createdAt: true;
    updatedAt: true;
    title: true;
    prioritize: true;
    completed: true;
};
declare type TodoGetSelectPayload<S extends boolean | TodoSelect> = S extends true ? Todo : S extends TodoSelect ? {
    [P in CleanupNever<MergeTruthyValues<{}, S>>]: P extends TodoScalars ? Todo[P] : P extends 'author' ? UserGetSelectPayload<ExtractUserSelectArgs<S[P]>> : never;
} : never;
declare type TodoGetIncludePayload<S extends boolean | TodoInclude> = S extends true ? Todo : S extends TodoInclude ? {
    [P in CleanupNever<MergeTruthyValues<TodoDefault, S>>]: P extends TodoScalars ? Todo[P] : P extends 'author' ? UserGetIncludePayload<ExtractUserIncludeArgs<S[P]>> : never;
} : never;
export interface TodoDelegate {
    <T extends FindManyTodoArgs>(args?: Subset<T, FindManyTodoArgs>): T extends FindManyTodoArgsRequired ? 'Please either choose `select` or `include`' : T extends FindManyTodoSelectArgs ? Promise<Array<TodoGetSelectPayload<ExtractFindManyTodoSelectArgs<T>>>> : T extends FindManyTodoIncludeArgs ? Promise<Array<TodoGetIncludePayload<ExtractFindManyTodoIncludeArgs<T>>>> : Promise<Array<Todo>>;
    findOne<T extends FindOneTodoArgs>(args: Subset<T, FindOneTodoArgs>): T extends FindOneTodoArgsRequired ? 'Please either choose `select` or `include`' : T extends FindOneTodoSelectArgs ? Promise<TodoGetSelectPayload<ExtractFindOneTodoSelectArgs<T>>> : T extends FindOneTodoIncludeArgs ? Promise<TodoGetIncludePayload<ExtractFindOneTodoIncludeArgs<T>>> : TodoClient<Todo>;
    findMany<T extends FindManyTodoArgs>(args?: Subset<T, FindManyTodoArgs>): T extends FindManyTodoArgsRequired ? 'Please either choose `select` or `include`' : T extends FindManyTodoSelectArgs ? Promise<Array<TodoGetSelectPayload<ExtractFindManyTodoSelectArgs<T>>>> : T extends FindManyTodoIncludeArgs ? Promise<Array<TodoGetIncludePayload<ExtractFindManyTodoIncludeArgs<T>>>> : Promise<Array<Todo>>;
    create<T extends TodoCreateArgs>(args: Subset<T, TodoCreateArgs>): T extends TodoCreateArgsRequired ? 'Please either choose `select` or `include`' : T extends TodoSelectCreateArgs ? Promise<TodoGetSelectPayload<ExtractTodoSelectCreateArgs<T>>> : T extends TodoIncludeCreateArgs ? Promise<TodoGetIncludePayload<ExtractTodoIncludeCreateArgs<T>>> : TodoClient<Todo>;
    delete<T extends TodoDeleteArgs>(args: Subset<T, TodoDeleteArgs>): T extends TodoDeleteArgsRequired ? 'Please either choose `select` or `include`' : T extends TodoSelectDeleteArgs ? Promise<TodoGetSelectPayload<ExtractTodoSelectDeleteArgs<T>>> : T extends TodoIncludeDeleteArgs ? Promise<TodoGetIncludePayload<ExtractTodoIncludeDeleteArgs<T>>> : TodoClient<Todo>;
    update<T extends TodoUpdateArgs>(args: Subset<T, TodoUpdateArgs>): T extends TodoUpdateArgsRequired ? 'Please either choose `select` or `include`' : T extends TodoSelectUpdateArgs ? Promise<TodoGetSelectPayload<ExtractTodoSelectUpdateArgs<T>>> : T extends TodoIncludeUpdateArgs ? Promise<TodoGetIncludePayload<ExtractTodoIncludeUpdateArgs<T>>> : TodoClient<Todo>;
    deleteMany<T extends TodoDeleteManyArgs>(args: Subset<T, TodoDeleteManyArgs>): T extends TodoDeleteManyArgsRequired ? 'Please either choose `select` or `include`' : T extends TodoSelectDeleteManyArgs ? Promise<TodoGetSelectPayload<ExtractTodoSelectDeleteManyArgs<T>>> : T extends TodoIncludeDeleteManyArgs ? Promise<TodoGetIncludePayload<ExtractTodoIncludeDeleteManyArgs<T>>> : TodoClient<Todo>;
    updateMany<T extends TodoUpdateManyArgs>(args: Subset<T, TodoUpdateManyArgs>): T extends TodoUpdateManyArgsRequired ? 'Please either choose `select` or `include`' : T extends TodoSelectUpdateManyArgs ? Promise<TodoGetSelectPayload<ExtractTodoSelectUpdateManyArgs<T>>> : T extends TodoIncludeUpdateManyArgs ? Promise<TodoGetIncludePayload<ExtractTodoIncludeUpdateManyArgs<T>>> : TodoClient<Todo>;
    upsert<T extends TodoUpsertArgs>(args: Subset<T, TodoUpsertArgs>): T extends TodoUpsertArgsRequired ? 'Please either choose `select` or `include`' : T extends TodoSelectUpsertArgs ? Promise<TodoGetSelectPayload<ExtractTodoSelectUpsertArgs<T>>> : T extends TodoIncludeUpsertArgs ? Promise<TodoGetIncludePayload<ExtractTodoIncludeUpsertArgs<T>>> : TodoClient<Todo>;
}
export declare class TodoClient<T> implements Promise<T> {
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _path;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: DMMFClass, _fetcher: PhotonFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: TodoArgs, _path: string[], _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PhotonPromise';
    author<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): T extends FindOneUserArgsRequired ? 'Please either choose `select` or `include`' : T extends UserSelectArgs ? Promise<UserGetSelectPayload<ExtractUserSelectArgs<T>>> : T extends UserIncludeArgs ? Promise<UserGetIncludePayload<ExtractUserIncludeArgs<T>>> : UserClient<User>;
    private readonly _document;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}
/**
 * Todo findOne
 */
export declare type FindOneTodoArgs = {
    select?: TodoSelect | null;
    include?: TodoInclude | null;
    where: TodoWhereUniqueInput;
};
export declare type FindOneTodoArgsRequired = {
    select: TodoSelect;
    include: TodoInclude;
    where: TodoWhereUniqueInput;
};
export declare type FindOneTodoSelectArgs = {
    select: TodoSelect;
    where: TodoWhereUniqueInput;
};
export declare type FindOneTodoSelectArgsOptional = {
    select?: TodoSelect | null;
    where: TodoWhereUniqueInput;
};
export declare type FindOneTodoIncludeArgs = {
    include: TodoInclude;
    where: TodoWhereUniqueInput;
};
export declare type FindOneTodoIncludeArgsOptional = {
    include?: TodoInclude | null;
    where: TodoWhereUniqueInput;
};
export declare type ExtractFindOneTodoSelectArgs<S extends undefined | boolean | FindOneTodoSelectArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends FindOneTodoSelectArgs ? S['select'] : true;
export declare type ExtractFindOneTodoIncludeArgs<S extends undefined | boolean | FindOneTodoIncludeArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends FindOneTodoIncludeArgs ? S['include'] : true;
/**
 * Todo findMany
 */
export declare type FindManyTodoArgs = {
    select?: TodoSelect | null;
    include?: TodoInclude | null;
    where?: TodoWhereInput | null;
    orderBy?: TodoOrderByInput | null;
    skip?: number | null;
    after?: string | null;
    before?: string | null;
    first?: number | null;
    last?: number | null;
};
export declare type FindManyTodoArgsRequired = {
    select: TodoSelect;
    include: TodoInclude;
    where?: TodoWhereInput | null;
    orderBy?: TodoOrderByInput | null;
    skip?: number | null;
    after?: string | null;
    before?: string | null;
    first?: number | null;
    last?: number | null;
};
export declare type FindManyTodoSelectArgs = {
    select: TodoSelect;
    where?: TodoWhereInput | null;
    orderBy?: TodoOrderByInput | null;
    skip?: number | null;
    after?: string | null;
    before?: string | null;
    first?: number | null;
    last?: number | null;
};
export declare type FindManyTodoSelectArgsOptional = {
    select?: TodoSelect | null;
    where?: TodoWhereInput | null;
    orderBy?: TodoOrderByInput | null;
    skip?: number | null;
    after?: string | null;
    before?: string | null;
    first?: number | null;
    last?: number | null;
};
export declare type FindManyTodoIncludeArgs = {
    include: TodoInclude;
    where?: TodoWhereInput | null;
    orderBy?: TodoOrderByInput | null;
    skip?: number | null;
    after?: string | null;
    before?: string | null;
    first?: number | null;
    last?: number | null;
};
export declare type FindManyTodoIncludeArgsOptional = {
    include?: TodoInclude | null;
    where?: TodoWhereInput | null;
    orderBy?: TodoOrderByInput | null;
    skip?: number | null;
    after?: string | null;
    before?: string | null;
    first?: number | null;
    last?: number | null;
};
export declare type ExtractFindManyTodoSelectArgs<S extends undefined | boolean | FindManyTodoSelectArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends FindManyTodoSelectArgs ? S['select'] : true;
export declare type ExtractFindManyTodoIncludeArgs<S extends undefined | boolean | FindManyTodoIncludeArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends FindManyTodoIncludeArgs ? S['include'] : true;
/**
 * Todo create
 */
export declare type TodoCreateArgs = {
    select?: TodoSelect | null;
    include?: TodoInclude | null;
    data: TodoCreateInput;
};
export declare type TodoCreateArgsRequired = {
    select: TodoSelect;
    include: TodoInclude;
    data: TodoCreateInput;
};
export declare type TodoSelectCreateArgs = {
    select: TodoSelect;
    data: TodoCreateInput;
};
export declare type TodoSelectCreateArgsOptional = {
    select?: TodoSelect | null;
    data: TodoCreateInput;
};
export declare type TodoIncludeCreateArgs = {
    include: TodoInclude;
    data: TodoCreateInput;
};
export declare type TodoIncludeCreateArgsOptional = {
    include?: TodoInclude | null;
    data: TodoCreateInput;
};
export declare type ExtractTodoSelectCreateArgs<S extends undefined | boolean | TodoSelectCreateArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends TodoSelectCreateArgs ? S['select'] : true;
export declare type ExtractTodoIncludeCreateArgs<S extends undefined | boolean | TodoIncludeCreateArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends TodoIncludeCreateArgs ? S['include'] : true;
/**
 * Todo update
 */
export declare type TodoUpdateArgs = {
    select?: TodoSelect | null;
    include?: TodoInclude | null;
    data: TodoUpdateInput;
    where: TodoWhereUniqueInput;
};
export declare type TodoUpdateArgsRequired = {
    select: TodoSelect;
    include: TodoInclude;
    data: TodoUpdateInput;
    where: TodoWhereUniqueInput;
};
export declare type TodoSelectUpdateArgs = {
    select: TodoSelect;
    data: TodoUpdateInput;
    where: TodoWhereUniqueInput;
};
export declare type TodoSelectUpdateArgsOptional = {
    select?: TodoSelect | null;
    data: TodoUpdateInput;
    where: TodoWhereUniqueInput;
};
export declare type TodoIncludeUpdateArgs = {
    include: TodoInclude;
    data: TodoUpdateInput;
    where: TodoWhereUniqueInput;
};
export declare type TodoIncludeUpdateArgsOptional = {
    include?: TodoInclude | null;
    data: TodoUpdateInput;
    where: TodoWhereUniqueInput;
};
export declare type ExtractTodoSelectUpdateArgs<S extends undefined | boolean | TodoSelectUpdateArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends TodoSelectUpdateArgs ? S['select'] : true;
export declare type ExtractTodoIncludeUpdateArgs<S extends undefined | boolean | TodoIncludeUpdateArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends TodoIncludeUpdateArgs ? S['include'] : true;
/**
 * Todo updateMany
 */
export declare type TodoUpdateManyArgs = {
    select?: TodoSelect | null;
    include?: TodoInclude | null;
    data: TodoUpdateManyMutationInput;
    where?: TodoWhereInput | null;
};
export declare type TodoUpdateManyArgsRequired = {
    select: TodoSelect;
    include: TodoInclude;
    data: TodoUpdateManyMutationInput;
    where?: TodoWhereInput | null;
};
export declare type TodoSelectUpdateManyArgs = {
    select: TodoSelect;
    data: TodoUpdateManyMutationInput;
    where?: TodoWhereInput | null;
};
export declare type TodoSelectUpdateManyArgsOptional = {
    select?: TodoSelect | null;
    data: TodoUpdateManyMutationInput;
    where?: TodoWhereInput | null;
};
export declare type TodoIncludeUpdateManyArgs = {
    include: TodoInclude;
    data: TodoUpdateManyMutationInput;
    where?: TodoWhereInput | null;
};
export declare type TodoIncludeUpdateManyArgsOptional = {
    include?: TodoInclude | null;
    data: TodoUpdateManyMutationInput;
    where?: TodoWhereInput | null;
};
export declare type ExtractTodoSelectUpdateManyArgs<S extends undefined | boolean | TodoSelectUpdateManyArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends TodoSelectUpdateManyArgs ? S['select'] : true;
export declare type ExtractTodoIncludeUpdateManyArgs<S extends undefined | boolean | TodoIncludeUpdateManyArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends TodoIncludeUpdateManyArgs ? S['include'] : true;
/**
 * Todo upsert
 */
export declare type TodoUpsertArgs = {
    select?: TodoSelect | null;
    include?: TodoInclude | null;
    where: TodoWhereUniqueInput;
    create: TodoCreateInput;
    update: TodoUpdateInput;
};
export declare type TodoUpsertArgsRequired = {
    select: TodoSelect;
    include: TodoInclude;
    where: TodoWhereUniqueInput;
    create: TodoCreateInput;
    update: TodoUpdateInput;
};
export declare type TodoSelectUpsertArgs = {
    select: TodoSelect;
    where: TodoWhereUniqueInput;
    create: TodoCreateInput;
    update: TodoUpdateInput;
};
export declare type TodoSelectUpsertArgsOptional = {
    select?: TodoSelect | null;
    where: TodoWhereUniqueInput;
    create: TodoCreateInput;
    update: TodoUpdateInput;
};
export declare type TodoIncludeUpsertArgs = {
    include: TodoInclude;
    where: TodoWhereUniqueInput;
    create: TodoCreateInput;
    update: TodoUpdateInput;
};
export declare type TodoIncludeUpsertArgsOptional = {
    include?: TodoInclude | null;
    where: TodoWhereUniqueInput;
    create: TodoCreateInput;
    update: TodoUpdateInput;
};
export declare type ExtractTodoSelectUpsertArgs<S extends undefined | boolean | TodoSelectUpsertArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends TodoSelectUpsertArgs ? S['select'] : true;
export declare type ExtractTodoIncludeUpsertArgs<S extends undefined | boolean | TodoIncludeUpsertArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends TodoIncludeUpsertArgs ? S['include'] : true;
/**
 * Todo delete
 */
export declare type TodoDeleteArgs = {
    select?: TodoSelect | null;
    include?: TodoInclude | null;
    where: TodoWhereUniqueInput;
};
export declare type TodoDeleteArgsRequired = {
    select: TodoSelect;
    include: TodoInclude;
    where: TodoWhereUniqueInput;
};
export declare type TodoSelectDeleteArgs = {
    select: TodoSelect;
    where: TodoWhereUniqueInput;
};
export declare type TodoSelectDeleteArgsOptional = {
    select?: TodoSelect | null;
    where: TodoWhereUniqueInput;
};
export declare type TodoIncludeDeleteArgs = {
    include: TodoInclude;
    where: TodoWhereUniqueInput;
};
export declare type TodoIncludeDeleteArgsOptional = {
    include?: TodoInclude | null;
    where: TodoWhereUniqueInput;
};
export declare type ExtractTodoSelectDeleteArgs<S extends undefined | boolean | TodoSelectDeleteArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends TodoSelectDeleteArgs ? S['select'] : true;
export declare type ExtractTodoIncludeDeleteArgs<S extends undefined | boolean | TodoIncludeDeleteArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends TodoIncludeDeleteArgs ? S['include'] : true;
/**
 * Todo deleteMany
 */
export declare type TodoDeleteManyArgs = {
    select?: TodoSelect | null;
    include?: TodoInclude | null;
    where?: TodoWhereInput | null;
};
export declare type TodoDeleteManyArgsRequired = {
    select: TodoSelect;
    include: TodoInclude;
    where?: TodoWhereInput | null;
};
export declare type TodoSelectDeleteManyArgs = {
    select: TodoSelect;
    where?: TodoWhereInput | null;
};
export declare type TodoSelectDeleteManyArgsOptional = {
    select?: TodoSelect | null;
    where?: TodoWhereInput | null;
};
export declare type TodoIncludeDeleteManyArgs = {
    include: TodoInclude;
    where?: TodoWhereInput | null;
};
export declare type TodoIncludeDeleteManyArgsOptional = {
    include?: TodoInclude | null;
    where?: TodoWhereInput | null;
};
export declare type ExtractTodoSelectDeleteManyArgs<S extends undefined | boolean | TodoSelectDeleteManyArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends TodoSelectDeleteManyArgs ? S['select'] : true;
export declare type ExtractTodoIncludeDeleteManyArgs<S extends undefined | boolean | TodoIncludeDeleteManyArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends TodoIncludeDeleteManyArgs ? S['include'] : true;
/**
 * Todo without action
 */
export declare type TodoArgs = {
    select?: TodoSelect | null;
    include?: TodoInclude | null;
};
export declare type TodoArgsRequired = {
    select: TodoSelect;
    include: TodoInclude;
};
export declare type TodoSelectArgs = {
    select: TodoSelect;
};
export declare type TodoSelectArgsOptional = {
    select?: TodoSelect | null;
};
export declare type TodoIncludeArgs = {
    include: TodoInclude;
};
export declare type TodoIncludeArgsOptional = {
    include?: TodoInclude | null;
};
export declare type ExtractTodoSelectArgs<S extends undefined | boolean | TodoSelectArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends TodoSelectArgs ? S['select'] : true;
export declare type ExtractTodoIncludeArgs<S extends undefined | boolean | TodoIncludeArgsOptional> = S extends undefined ? false : S extends boolean ? S : S extends TodoIncludeArgs ? S['include'] : true;
/**
 * Deep Input Types
 */
export declare type TodoWhereInput = {
    id?: string | StringFilter | null;
    createdAt?: string | Date | DateTimeFilter | null;
    updatedAt?: string | Date | DateTimeFilter | null;
    title?: string | StringFilter | null;
    prioritize?: boolean | NullableBooleanFilter | null | null;
    completed?: boolean | NullableBooleanFilter | null | null;
    AND?: Enumerable<TodoWhereInput>;
    OR?: Enumerable<TodoWhereInput>;
    NOT?: Enumerable<TodoWhereInput>;
    author?: UserWhereInput | null;
};
export declare type UserWhereInput = {
    id?: string | StringFilter | null;
    email?: string | StringFilter | null;
    name?: string | NullableStringFilter | null | null;
    todos?: TodoFilter | null;
    AND?: Enumerable<UserWhereInput>;
    OR?: Enumerable<UserWhereInput>;
    NOT?: Enumerable<UserWhereInput>;
};
export declare type UserWhereUniqueInput = {
    id?: string | null;
    email?: string | null;
};
export declare type TodoWhereUniqueInput = {
    id?: string | null;
};
export declare type TodoCreateWithoutAuthorInput = {
    id?: string | null;
    createdAt?: string | Date | null;
    updatedAt?: string | Date | null;
    title: string;
    prioritize?: boolean | null;
    completed?: boolean | null;
};
export declare type TodoCreateManyWithoutTodosInput = {
    create?: Enumerable<TodoCreateWithoutAuthorInput>;
    connect?: Enumerable<TodoWhereUniqueInput>;
};
export declare type UserCreateInput = {
    id?: string | null;
    email: string;
    name?: string | null;
    todos?: TodoCreateManyWithoutTodosInput | null;
};
export declare type TodoUpdateWithoutAuthorDataInput = {
    id?: string | null;
    createdAt?: string | Date | null;
    updatedAt?: string | Date | null;
    title?: string | null;
    prioritize?: boolean | null;
    completed?: boolean | null;
};
export declare type TodoUpdateWithWhereUniqueWithoutAuthorInput = {
    where: TodoWhereUniqueInput;
    data: TodoUpdateWithoutAuthorDataInput;
};
export declare type TodoScalarWhereInput = {
    id?: string | StringFilter | null;
    createdAt?: string | Date | DateTimeFilter | null;
    updatedAt?: string | Date | DateTimeFilter | null;
    title?: string | StringFilter | null;
    prioritize?: boolean | NullableBooleanFilter | null | null;
    completed?: boolean | NullableBooleanFilter | null | null;
    AND?: Enumerable<TodoScalarWhereInput>;
    OR?: Enumerable<TodoScalarWhereInput>;
    NOT?: Enumerable<TodoScalarWhereInput>;
};
export declare type TodoUpdateManyDataInput = {
    id?: string | null;
    createdAt?: string | Date | null;
    updatedAt?: string | Date | null;
    title?: string | null;
    prioritize?: boolean | null;
    completed?: boolean | null;
};
export declare type TodoUpdateManyWithWhereNestedInput = {
    where: TodoScalarWhereInput;
    data: TodoUpdateManyDataInput;
};
export declare type TodoUpsertWithWhereUniqueWithoutAuthorInput = {
    where: TodoWhereUniqueInput;
    update: TodoUpdateWithoutAuthorDataInput;
    create: TodoCreateWithoutAuthorInput;
};
export declare type TodoUpdateManyWithoutAuthorInput = {
    create?: Enumerable<TodoCreateWithoutAuthorInput>;
    connect?: Enumerable<TodoWhereUniqueInput>;
    set?: Enumerable<TodoWhereUniqueInput>;
    disconnect?: Enumerable<TodoWhereUniqueInput>;
    delete?: Enumerable<TodoWhereUniqueInput>;
    update?: Enumerable<TodoUpdateWithWhereUniqueWithoutAuthorInput>;
    updateMany?: Enumerable<TodoUpdateManyWithWhereNestedInput>;
    deleteMany?: Enumerable<TodoScalarWhereInput>;
    upsert?: Enumerable<TodoUpsertWithWhereUniqueWithoutAuthorInput>;
};
export declare type UserUpdateInput = {
    id?: string | null;
    email?: string | null;
    name?: string | null;
    todos?: TodoUpdateManyWithoutAuthorInput | null;
};
export declare type UserUpdateManyMutationInput = {
    id?: string | null;
    email?: string | null;
    name?: string | null;
};
export declare type UserCreateWithoutTodosInput = {
    id?: string | null;
    email: string;
    name?: string | null;
};
export declare type UserCreateOneWithoutAuthorInput = {
    create?: UserCreateWithoutTodosInput | null;
    connect?: UserWhereUniqueInput | null;
};
export declare type TodoCreateInput = {
    id?: string | null;
    createdAt?: string | Date | null;
    updatedAt?: string | Date | null;
    title: string;
    prioritize?: boolean | null;
    completed?: boolean | null;
    author?: UserCreateOneWithoutAuthorInput | null;
};
export declare type UserUpdateWithoutTodosDataInput = {
    id?: string | null;
    email?: string | null;
    name?: string | null;
};
export declare type UserUpsertWithoutTodosInput = {
    update: UserUpdateWithoutTodosDataInput;
    create: UserCreateWithoutTodosInput;
};
export declare type UserUpdateOneWithoutTodosInput = {
    create?: UserCreateWithoutTodosInput | null;
    connect?: UserWhereUniqueInput | null;
    disconnect?: boolean | null;
    delete?: boolean | null;
    update?: UserUpdateWithoutTodosDataInput | null;
    upsert?: UserUpsertWithoutTodosInput | null;
};
export declare type TodoUpdateInput = {
    id?: string | null;
    createdAt?: string | Date | null;
    updatedAt?: string | Date | null;
    title?: string | null;
    prioritize?: boolean | null;
    completed?: boolean | null;
    author?: UserUpdateOneWithoutTodosInput | null;
};
export declare type TodoUpdateManyMutationInput = {
    id?: string | null;
    createdAt?: string | Date | null;
    updatedAt?: string | Date | null;
    title?: string | null;
    prioritize?: boolean | null;
    completed?: boolean | null;
};
export declare type StringFilter = {
    equals?: string | null;
    not?: string | StringFilter | null;
    in?: Enumerable<string>;
    notIn?: Enumerable<string>;
    lt?: string | null;
    lte?: string | null;
    gt?: string | null;
    gte?: string | null;
    contains?: string | null;
    startsWith?: string | null;
    endsWith?: string | null;
};
export declare type DateTimeFilter = {
    equals?: string | Date | null;
    not?: string | Date | DateTimeFilter | null;
    in?: Enumerable<string | Date>;
    notIn?: Enumerable<string | Date>;
    lt?: string | Date | null;
    lte?: string | Date | null;
    gt?: string | Date | null;
    gte?: string | Date | null;
};
export declare type NullableBooleanFilter = {
    equals?: boolean | null | null;
    not?: boolean | null | NullableBooleanFilter | null;
};
export declare type NullableStringFilter = {
    equals?: string | null | null;
    not?: string | null | NullableStringFilter | null;
    in?: Enumerable<string>;
    notIn?: Enumerable<string>;
    lt?: string | null;
    lte?: string | null;
    gt?: string | null;
    gte?: string | null;
    contains?: string | null;
    startsWith?: string | null;
    endsWith?: string | null;
};
export declare type TodoFilter = {
    every?: TodoWhereInput | null;
    some?: TodoWhereInput | null;
    none?: TodoWhereInput | null;
};
export declare type UserOrderByInput = {
    id?: OrderByArg | null;
    email?: OrderByArg | null;
    name?: OrderByArg | null;
};
export declare type TodoOrderByInput = {
    id?: OrderByArg | null;
    createdAt?: OrderByArg | null;
    updatedAt?: OrderByArg | null;
    title?: OrderByArg | null;
    prioritize?: OrderByArg | null;
    completed?: OrderByArg | null;
};
/**
 * DMMF
 */
export declare const dmmf: DMMF.Document;
export {};
